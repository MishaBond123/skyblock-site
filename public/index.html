<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Bazaar Orders — Ghost Levels (ENHANCED)</title>
  <link rel="icon" type="image/jpeg" href="site-icon.png"/>

  <style>
    :root {
      --card: rgba(0,0,0,0.65);
      --text: #f5f7fa;
      --muted: rgba(255,255,255,0.75);
      --accent: #00bfff;
      --ghost: rgba(186,114,255,0.18);
      --warn1: rgba(255,255,0,0.15);
      --warn2: rgba(255,80,80,0.25);
      --hl: rgba(0,191,255,0.25);
      --border: rgba(255,255,255,0.12);
      --head: rgba(0,191,255,0.28);
      --up: #27d17f;
      --down: #ff5f5f;
      --neutral: #a3b1c6;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; color: var(--text);
      background-image: url('bgimage.jpeg');
      background-size: cover;
      background-attachment: fixed;
      background-position: center;
      font-family: system-ui, Segoe UI, Roboto, sans-serif;
    }
    .container { max-width: 1280px; margin: 36px auto; padding: 0 16px; }
    h1 { margin: 0 0 20px; font-weight: 800; letter-spacing: .2px; }

    .panel {
      background: var(--card); border: 1px solid var(--border);
      border-radius: 16px; padding: 16px; margin-bottom: 16px;
      backdrop-filter: saturate(120%) blur(2px);
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
    }

    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    @media (max-width: 1024px) { .grid-2 { grid-template-columns: 1fr; } }

    label { user-select: none; cursor: pointer; display: block; margin-bottom: 6px; }
    input[type="text"]{
      width: 100%; padding: 12px 12px; border-radius: 12px; border: 1px solid var(--border);
      background: rgba(255,255,255,0.06); color: var(--text); font-size: 15px; outline: none;
    }
    input[type="checkbox"] { transform: translateY(1px); }
    .row { display: flex; gap: 16px; align-items: stretch; flex-wrap: wrap; }
    .muted { color: var(--muted); font-size: 14px; }

    table { width: 100%; border-collapse: collapse; overflow: hidden; border-radius: 12px; }
    thead th {
      background: var(--head); padding: 10px; text-align: center; font-weight: 700;
      border-bottom: 1px solid var(--border);
    }
    tbody td { padding: 10px; text-align: center; border-bottom: 1px solid rgba(255,255,255,0.06); font-size: 14px; }
    tfoot td { padding: 10px; font-weight: 700; background: rgba(255,255,255,0.07); }
    tr:nth-child(even) td { background: rgba(255,255,255,0.03); }

    .highlight-yellow { background: var(--warn1) !important; }
    .highlight-red    { background: var(--warn2) !important; }
    .highlight-blue   { background: var(--hl) !important; }
    .highlight-ghost  { background: var(--ghost) !important; }

    .dropdown {
      background: var(--card); border: 1px solid var(--border);
      border-radius: 12px; padding: 6px; max-height: 340px; overflow-y: auto; display: none; margin-top: 6px;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
    }
    .dropdown-item {
      display: flex; align-items: center; justify-content: space-between;
      gap: 12px; padding: 10px 12px; border-radius: 10px; cursor: pointer; transition: background .15s;
    }
    .dropdown-item:hover { background: rgba(255,255,255,0.06); }
    .pill { background: goldenrod; color: black; padding: 2px 8px; border-radius: 999px; font-weight: 700; font-size: 12px; }

    .stats {
      display: grid; grid-template-columns: repeat(4, minmax(160px, 1fr)); gap: 12px;
    }
    @media (max-width: 1024px) { .stats { grid-template-columns: repeat(2, 1fr); } }
    @media (max-width: 520px)  { .stats { grid-template-columns: 1fr; } }
    .stat {
      background: rgba(255,255,255,0.06); border: 1px solid var(--border); border-radius: 12px; padding: 12px;
    }
    .stat-label { font-size: 12px; color: var(--muted); text-transform: uppercase; letter-spacing: .6px; }
    .stat-value { font-size: 18px; font-weight: 800; display: flex; align-items: center; gap: 8px; }
    .delta { font-size: 12px; font-weight: 700; padding: 2px 6px; border-radius: 999px; background: rgba(255,255,255,0.08); }
    .delta-up { color: var(--up); }
    .delta-down { color: var(--down); }
    .delta-flat { color: var(--neutral); }

    .volume { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px 24px; }
    .volume strong { font-weight: 700; }
    .spread { margin-top: 10px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.15); }

    .kicker { display:flex; align-items:center; justify-content:space-between; gap:12px; }
    .badge { font-size:12px; background:rgba(255,255,255,0.08); border:1px solid var(--border); padding:4px 8px; border-radius:999px; }
  </style>
</head>
<body>
  <div class="container">
    <div class="kicker">
      <h1>Bazaar Orders</h1>
      <div class="muted" id="lastUpdated">—</div>
    </div>

    <div class="panel">
      <div id="topStats" class="stats"></div>
    </div>

    <div class="panel">
      <div class="row">
        <div style="flex:1 1 420px; min-width:280px;">
          <label>Item ID</label>
          <input id="itemInput" type="text" placeholder="Enter Item ID (e.g., BOOSTER_COOKIE)"/>
          <div id="itemDropdown" class="dropdown"></div>
          <div class="muted" id="chartLink" style="margin-top:6px;"></div>
        </div>
        <div style="flex:1 1 360px; min-width:260px;">
          <label>Track Order By Price</label>
          <input id="trackInput" type="text" placeholder="Enter price to track"/>
          <label class="muted" style="margin-top:6px;"><input id="groupToggle" type="checkbox"/> Group live prices within ±0.15%</label>
          <div class="muted" style="margin-top:6px;">
            <span class="badge">Ghosts = remembered price levels (0.1 precision) below live orders</span>
          </div>
        </div>
      </div>
    </div>

    <div id="orderInfo" class="panel" style="display:none;"></div>

    <div class="grid-2">
      <div class="panel">
        <h2 style="margin:0 0 10px;">Buy Orders (expensive → cheapest)</h2>
        <table id="buyTable">
          <thead><tr><th>Orders</th><th>Amount</th><th>Unit Price</th><th>Coin Equivalent</th></tr></thead>
          <tbody></tbody>
          <tfoot><tr><td>Total:</td><td></td><td></td><td></td></tr></tfoot>
        </table>
      </div>
      <div class="panel">
        <h2 style="margin:0 0 10px;">Sell Orders (cheapest → expensive)</h2>
        <table id="sellTable">
          <thead><tr><th>Orders</th><th>Amount</th><th>Unit Price</th><th>Coin Equivalent</th></tr></thead>
          <tbody></tbody>
          <tfoot><tr><td>Total:</td><td></td><td></td><td></td></tr></tfoot>
        </table>
      </div>
    </div>
  </div>

  <script type="module">
const GROUP_PCT = 0.15;
const POLL_MS = 3000;

const itemInput  = document.getElementById("itemInput");
const itemDropdown = document.getElementById("itemDropdown");
const chartLink  = document.getElementById("chartLink");
const trackInput = document.getElementById("trackInput");
const groupToggle = document.getElementById("groupToggle");
const lastUpdated = document.getElementById("lastUpdated");

const topStats = document.getElementById("topStats");

const buyBody  = document.querySelector("#buyTable tbody");
const sellBody = document.querySelector("#sellTable tbody");
const buyFoot  = document.querySelector("#buyTable tfoot tr");
const sellFoot = document.querySelector("#sellTable tfoot tr");

const orderInfo = document.getElementById("orderInfo");

let currentItemId = "";
let allItems = [];
let latestBuySummary = [];
let latestSellSummary = [];
let lastHourlyBuyVolume  = 0;  // avg instasells per hour
let lastHourlySellVolume = 0;  // avg instabuys per hour
let useGrouping = false;

let prevBuySortedDesc = [];
let prevSellSortedAsc = [];

// Metric cache for deltas
const prevMetrics = new Map();
const EPS = 1e-9;

function dbg(...args){console.log(`[${new Date().toISOString()}] [GHOST DEBUG]`,...args);} 
const fmt = {
  coins(n){ if (!isFinite(n)) return '—'; return Math.round(n).toLocaleString(); },
  price(n){ if (!isFinite(n)) return '—'; return `${n.toLocaleString()} coins`; },
  sig(n, s=6){ if (!isFinite(n)) return '—'; return Number(n).toPrecision(s); },
  pct(n, s=2){ if (!isFinite(n)) return '—'; return `${Number(n).toFixed(s)}%`; },
}
function keyPrice(p){ return Math.round(p * 10) / 10; }
function sameLevel(a, b){ return keyPrice(a) === keyPrice(b); }
function storageKey(itemId, side){ return `remembered:${itemId}:${side}`; }
function readRemembered(itemId, side){ try { return JSON.parse(localStorage.getItem(storageKey(itemId,side)) || "[]"); } catch { return []; } }
function writeRemembered(itemId, side, arr){ try { localStorage.setItem(storageKey(itemId,side), JSON.stringify(arr)); } catch {} }
function addGhost(itemId, side, price, amount, orders){ const arr = readRemembered(itemId, side); const k = keyPrice(price); if (!arr.some(x => sameLevel(x.price, k))) { arr.push({ price: k, amount: amount ?? 0, orders: orders ?? 1, ts: Date.now() }); writeRemembered(itemId, side, arr); } }
function crossed(side, price, bestBid, bestAsk){ return side==="buy" ? price >= bestAsk - EPS : price <= bestBid + EPS; }

function groupSummary(summary, pct = GROUP_PCT) {
  if (!Array.isArray(summary) || summary.length === 0) return [];
  const tol = pct / 100;
  const arr = [...summary];
  const out = [];
  let cur = null;
  const pushCur = () => { if (cur){ delete cur._coins; out.push(cur); } };
  for (const row of arr) {
    const base = { ...row, _coins: row.amount * row.pricePerUnit };
    if (!cur) { cur = base; continue; }
    const rel = Math.abs(row.pricePerUnit - cur.pricePerUnit) / (cur.pricePerUnit || 1);
    if (rel <= tol) {
      cur.orders += row.orders;
      cur.amount += row.amount;
      cur._coins += row.amount * row.pricePerUnit;
      cur.pricePerUnit = cur._coins / cur.amount;
    } else { pushCur(); cur = base; }
  }
  pushCur();
  return out;
}

function buildDisplaysWithGhosts(apiSellSummary, apiBuySummary) {
  const buyGhosts = readRemembered(currentItemId, "buy")
    .filter(r => !apiSellSummary.some(x => sameLevel(x.pricePerUnit, r.price)))
    .map(r => ({ orders: r.orders ?? 1, amount: r.amount ?? 0, pricePerUnit: keyPrice(r.price), ghost: true }));
  const sellGhosts = readRemembered(currentItemId, "sell")
    .filter(r => !apiBuySummary.some(x => sameLevel(x.pricePerUnit, r.price)))
    .map(r => ({ orders: r.orders ?? 1, amount: r.amount ?? 0, pricePerUnit: keyPrice(r.price), ghost: true }));
  const apiSellGrouped = useGrouping ? groupSummary(apiSellSummary) : [...apiSellSummary];
  const apiBuyGrouped  = useGrouping ? groupSummary(apiBuySummary)  : [...apiBuySummary];
  const buyCombined  = [...apiSellGrouped, ...buyGhosts].sort((a,b)=> (!!a.ghost !== !!b.ghost) ? (a.ghost ? 1 : -1) : (b.pricePerUnit - a.pricePerUnit));
  const sellCombined = [...apiBuyGrouped,  ...sellGhosts].sort((a,b)=> (!!a.ghost !== !!b.ghost) ? (a.ghost ? 1 : -1) : (a.pricePerUnit - b.pricePerUnit));
  return { buyDisplay: buyCombined, sellDisplay: sellCombined };
}

function renderTable(summary, tbody, tfootRow, hourlyVolume){
  tbody.innerHTML = "";
  let totalAmount=0, totalCoins=0;
  for (const row of summary) {
    const total = row.amount * row.pricePerUnit;
    totalAmount += row.amount; totalCoins += total;
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${row.orders}</td>
      <td>${row.amount}</td>
      <td>${fmt.price(row.pricePerUnit)}</td>
      <td>${fmt.coins(total)} coins</td>
    `;
    if (row.ghost) tr.classList.add("highlight-ghost");
    else {
      if (row.amount > hourlyVolume * 5) tr.classList.add("highlight-red");
      else if (row.amount > hourlyVolume) tr.classList.add("highlight-yellow");
    }
    tbody.appendChild(tr);
  }
  tfootRow.innerHTML = `
    <td>Total:</td>
    <td>${totalAmount}</td>
    <td></td>
    <td>${fmt.coins(totalCoins)} coins</td>
  `;
}

function renderCurrentTables() {
  const { buyDisplay, sellDisplay } = buildDisplaysWithGhosts(latestBuySummary, latestSellSummary);
  renderTable(buyDisplay,  buyBody,  buyFoot,  lastHourlyBuyVolume);
  renderTable(sellDisplay, sellBody, sellFoot, lastHourlySellVolume);
  const tracked = parseFloat((trackInput.value || "").replace(/,/g, ''));
  highlightTrackedOrder(tracked, buyDisplay, sellDisplay);
}

function highlightTrackedOrder(price, buyShown, sellShown){
  orderInfo.style.display = "none";
  orderInfo.innerHTML = "";
  if (!price || isNaN(price)) return;
  [...buyBody.children, ...sellBody.children].forEach(r => r.classList.remove("highlight-blue"));
  for (const [summary, body] of [[buyShown, buyBody], [sellShown, sellBody]]) {
    let coinsBetween=0, itemsBetween=0, priority=1;
    for (let i=0;i<summary.length;i++){
      const row = summary[i];
      const unit = parseFloat(keyPrice(row.pricePerUnit).toFixed(1));
      if (Math.abs(unit - price) < 0.1) {
        const tr = body.children[i];
        if (tr) tr.classList.add("highlight-blue");
        orderInfo.style.display = "block";
        orderInfo.innerHTML = `
          <strong>Tracked Order Info</strong><br/>
          Priority position: ${priority}<br/>
          Items between: ${itemsBetween}<br/>
          Coin gap: ${fmt.coins(coinsBetween)} coins<br/>
          Items left in order: ${row.amount}
        `;
        return;
      }
      itemsBetween += row.amount;
      coinsBetween += row.amount * row.pricePerUnit;
      priority++;
    }
  }
}

function rememberVanishedOutsideTop13(curBuyDesc, curSellAsc) {
  const curBuyKeys  = new Set(curBuyDesc.map(r => keyPrice(r.pricePerUnit)));
  const curSellKeys = new Set(curSellAsc.map(r => keyPrice(r.pricePerUnit)));
  prevBuySortedDesc.forEach((r, idx) => {
    if (idx >= 13) {
      const k = keyPrice(r.pricePerUnit);
      if (!curBuyKeys.has(k)) { addGhost(currentItemId, "buy", k, r.amount, r.orders); }
    }
  });
  prevSellSortedAsc.forEach((r, idx) => {
    if (idx >= 13) {
      const k = keyPrice(r.pricePerUnit);
      if (!curSellKeys.has(k)) { addGhost(currentItemId, "sell", k, r.amount, r.orders); }
    }
  });
}

function cleanGhostsAgainstCurrent(curBuyDesc, curSellAsc) {
  const buyLevels  = curBuyDesc.map(r => keyPrice(r.pricePerUnit));
  const sellLevels = curSellAsc.map(r => keyPrice(r.pricePerUnit));
  const bestAsk = Math.min(...curBuyDesc.map(r => r.pricePerUnit || Infinity));
  const bestBid = Math.max(...curSellAsc.map(r => r.pricePerUnit || -Infinity));
  let keptBuy = [];
  for (const g of readRemembered(currentItemId, "buy")) {
    const k = keyPrice(g.price);
    if (buyLevels.includes(k)) continue;
    if (crossed("buy", k, bestBid, bestAsk)) { continue; }
    keptBuy.push(g);
  }
  writeRemembered(currentItemId, "buy", keptBuy);
  let keptSell = [];
  for (const g of readRemembered(currentItemId, "sell")) {
    const k = keyPrice(g.price);
    if (sellLevels.includes(k)) continue;
    if (crossed("sell", k, bestBid, bestAsk)) { continue; }
    keptSell.push(g);
  }
  writeRemembered(currentItemId, "sell", keptSell);
}

// === New: metric rendering with deltas ===
function deltaSpan(key, newVal, {isPct=false, sig=6, coins=false}={}){
  const oldVal = prevMetrics.has(key) ? prevMetrics.get(key) : null;
  prevMetrics.set(key, newVal);
  if (oldVal === null || !isFinite(newVal) || !isFinite(oldVal)) return `<span class="delta delta-flat">(—)</span>`;
  const diff = newVal - oldVal;
  if (Math.abs(diff) < 1e-12) return `<span class="delta delta-flat">(0)</span>`;
  const cls = diff > 0 ? 'delta-up' : 'delta-down';
  const sign = diff > 0 ? '+' : '−';
  const abs = Math.abs(diff);
  let text;
  if (coins) text = `${sign}${fmt.coins(abs)}`;
  else if (isPct) text = `${sign}${Math.abs(diff).toFixed(2)}%`;
  else text = `${sign}${Number(abs).toPrecision(sig)}`;
  return `<span class="delta ${cls}">(${text})</span>`;
}

function statTile(label, valueHtml){
  return `<div class="stat"><div class="stat-label">${label}</div><div class="stat-value">${valueHtml}</div></div>`;
}

function renderTopStats(){
  // Compute best bid/ask from live summaries
  const bestAsk = Math.min(...latestBuySummary.map(r=>r.pricePerUnit || Infinity));
  const bestBid = Math.max(...latestSellSummary.map(r=>r.pricePerUnit || -Infinity));
  const mid = (bestAsk + bestBid) / 2;
  const spreadCoins = (bestAsk - bestBid);
  // Use mid for % spread when valid
  const spreadPct = (isFinite(mid) && mid > 0) ? (spreadCoins / mid) * 100 : NaN;

  // Hourly volumes (insta) — show to 6 significant figures
  const vBuy  = lastHourlySellVolume; // avg instabuys/hour
  const vSell = lastHourlyBuyVolume;  // avg instasells/hour

  const avgSellOrder = averageAmount(latestBuySummary);
  const avgBuyOrder  = averageAmount(latestSellSummary);

  topStats.innerHTML = [
    statTile('Best Ask', `${fmt.price(bestAsk)} ${deltaSpan('bestAsk', bestAsk, {sig:6})}`),
    statTile('Best Bid', `${fmt.price(bestBid)} ${deltaSpan('bestBid', bestBid, {sig:6})}`),
    statTile('Mid Price', `${fmt.price(mid)} ${deltaSpan('mid', mid, {sig:6})}`),
    statTile('Spread', `${fmt.coins(spreadCoins)} coins ${deltaSpan('spreadCoins', spreadCoins, {coins:true})}`),
    statTile('Spread %', `${fmt.pct(spreadPct, 3)} ${deltaSpan('spreadPct', spreadPct, {isPct:true})}`),
    statTile('Avg Instabuys / hr', `${fmt.sig(vBuy, 6)} ${deltaSpan('vBuy', vBuy, {sig:6})}`),
    statTile('Avg Instasells / hr', `${fmt.sig(vSell, 6)} ${deltaSpan('vSell', vSell, {sig:6})}`),
    statTile('Avg Sell-Order Amount', `${fmt.sig(avgSellOrder, 6)} ${deltaSpan('avgSellOrder', avgSellOrder, {sig:6})}`),
    statTile('Avg Buy-Order Amount', `${fmt.sig(avgBuyOrder, 6)} ${deltaSpan('avgBuyOrder', avgBuyOrder, {sig:6})}`),
    statTile('Top-of-Book Size (Ask)', `${fmt.coins(topLevelAmount(latestBuySummary))} ${deltaSpan('topAskSize', topLevelAmount(latestBuySummary), {coins:true})}`),
    statTile('Top-of-Book Size (Bid)', `${fmt.coins(topLevelAmount(latestSellSummary))} ${deltaSpan('topBidSize', topLevelAmount(latestSellSummary), {coins:true})}`),
    statTile('Depth (±0.5%)', `${fmt.coins(depthNotional(latestSellSummary, latestBuySummary, 0.5))} ${deltaSpan('depth05', depthNotional(latestSellSummary, latestBuySummary, 0.5), {coins:true})}`),
  ].join('');
}

function topLevelAmount(summary){
  if (!summary.length) return 0;
  // For sells (asks): cheapest is min price; for buys (bids): highest is max price
  const isAsk = summary === latestBuySummary;
  const pick = isAsk ? Math.min(...summary.map(r=>r.pricePerUnit)) : Math.max(...summary.map(r=>r.pricePerUnit));
  const lvl = summary.filter(r => Math.abs(r.pricePerUnit - pick) < 1e-9);
  return lvl.reduce((s,r)=>s+r.amount,0);
}

function depthNotional(bidSummary, askSummary, pctBand){
  // Approximate notional depth within ±pctBand around mid; use group of first 20 on each side
  if (!bidSummary.length || !askSummary.length) return 0;
  const bestAsk = Math.min(...askSummary.map(r=>r.pricePerUnit));
  const bestBid = Math.max(...bidSummary.map(r=>r.pricePerUnit));
  const mid = (bestAsk + bestBid)/2; if (!isFinite(mid) || mid<=0) return 0;
  const lo = mid*(1 - pctBand/100), hi = mid*(1 + pctBand/100);
  const asks = askSummary.filter(r => r.pricePerUnit >= lo && r.pricePerUnit <= hi).slice(0,20);
  const bids = bidSummary.filter(r => r.pricePerUnit >= lo && r.pricePerUnit <= hi).slice(0,20);
  const notional = asks.reduce((s,r)=>s + r.amount*r.pricePerUnit, 0) + bids.reduce((s,r)=>s + r.amount*r.pricePerUnit, 0);
  return notional;
}

function updateLastUpdated(){
  const d = new Date();
  lastUpdated.textContent = `Updated ${d.toLocaleTimeString()} (every ${Math.round(POLL_MS/1000)}s)`;
}

async function getApiKey(){ return ""; }

async function fetchAllItems(){
  const key = await getApiKey();
  const url = key ? `https://api.hypixel.net/skyblock/bazaar?key=${key}` : `https://api.hypixel.net/skyblock/bazaar`;
  const res = await fetch(url);
  const json = await res.json();
  const products = json.products || {};
  allItems = Object.keys(products).map(id => {
    const q = products[id].quick_status;
    const price = q.sellPrice > 1e6 ? (q.sellPrice/1e6).toFixed(2)+'M' :
                  q.sellPrice > 1e3 ? (q.sellPrice/1e3).toFixed(1)+'k' :
                  q.sellPrice.toFixed(1);
    return { id, name: id.replace(/_/g,' ').toLowerCase().replace(/\b\w/g,c=>c.toUpperCase()), price };
  });
}

function populateDropdown(query){
  const filtered = allItems.filter(i => i.name.toLowerCase().includes(query) || i.id.toLowerCase().includes(query));
  itemDropdown.innerHTML = "";
  for (const item of filtered.slice(0, 80)) {
    const div = document.createElement("div");
    div.className = "dropdown-item";
    div.innerHTML = `<div>${item.name}</div><div class="pill">${item.price} /bz</div>`;
    div.onclick = () => { itemInput.value = item.id; itemDropdown.style.display = "none"; selectItem(item.id); };
    itemDropdown.appendChild(div);
  }
  itemDropdown.style.display = filtered.length ? "block" : "none";
}

itemInput.addEventListener("input", () => {
  const query = itemInput.value.trim().toLowerCase();
  if (!query) { itemDropdown.style.display = "none"; return; }
  if (allItems.length === 0) { fetchAllItems().then(() => populateDropdown(query)); }
  else { populateDropdown(query); }
});

function selectItem(id){
  currentItemId = id;
  prevBuySortedDesc = [];
  prevSellSortedAsc = [];
  prevMetrics.clear(); // reset deltas when switching items
  chartLink.innerHTML = `Chart: <a href="https://skyblock.finance/items/${id}/chart" target="_blank" style="color:var(--accent);">skyblock.finance/items/${id}/chart</a>`;
  loadData(id);
  const url = new URL(window.location);
  url.searchParams.set("item", id);
  history.replaceState({}, "", url);
}

trackInput.addEventListener("change", () => {
  const tracked = parseFloat((trackInput.value||"").replace(/,/g,''));
  const { buyDisplay, sellDisplay } = buildDisplaysWithGhosts(latestBuySummary, latestSellSummary);
  highlightTrackedOrder(tracked, buyDisplay, sellDisplay);
});

groupToggle.addEventListener("change", () => { useGrouping = groupToggle.checked; renderCurrentTables(); renderTopStats(); });

async function loadData(itemId){
  const key = await getApiKey();
  const url = key ? `https://api.hypixel.net/skyblock/bazaar?key=${key}` : `https://api.hypixel.net/skyblock/bazaar`;
  const res = await fetch(url);
  const json = await res.json();
  const data = json.products?.[itemId];
  if (!data) return;

  // Hourly estimates (moving week / 168)
  const avgInstabuys  = data.quick_status.buyMovingWeek  / 168;
  const avgInstasells = data.quick_status.sellMovingWeek / 168;

  latestBuySummary  = data.sell_summary ?? [];
  latestSellSummary = data.buy_summary  ?? [];

  lastHourlyBuyVolume  = avgInstasells;
  lastHourlySellVolume = avgInstabuys;

  // Render
  renderCurrentTables();
  renderTopStats();
  updateLastUpdated();

  // Track prior levels for ghost logic cleanup
  const curBuySortedDesc = [...latestBuySummary].sort((a,b)=> b.pricePerUnit - a.pricePerUnit);
  const curSellSortedAsc = [...latestSellSummary].sort((a,b)=> a.pricePerUnit - b.pricePerUnit);
  if (prevBuySortedDesc.length || prevSellSortedAsc.length) rememberVanishedOutsideTop13(curBuySortedDesc, curSellSortedAsc);
  cleanGhostsAgainstCurrent(curBuySortedDesc, curSellSortedAsc);
  prevBuySortedDesc = curBuySortedDesc;
  prevSellSortedAsc = curSellSortedAsc;
}

function averageAmount(summary){ if (!summary.length) return 0; return summary.reduce((s,r)=>s+r.amount,0) / summary.length; }

const urlParams = new URLSearchParams(location.search);
const preItem = urlParams.get("item");
const preTrack = urlParams.get("track");
if (preItem) { itemInput.value = preItem; selectItem(preItem); }
if (preTrack) trackInput.value = preTrack;

setInterval(() => { if (currentItemId) loadData(currentItemId); }, POLL_MS);
fetchAllItems();
  </script>
</body>
</html>
