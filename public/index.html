<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Bazaar Orders — Minimal</title>
  <style>
    :root {
      --bg: #0b0f14;
      --card: rgba(255,255,255,0.06);
      --text: #f5f7fa;
      --muted: rgba(255,255,255,0.7);
      --accent: #00bfff;
      --ghost: rgba(186,114,255,0.18);
      --warn1: rgba(255,255,0,0.15);
      --warn2: rgba(255,80,80,0.25);
      --hl: rgba(0,191,255,0.25);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; color: var(--text);
      background: radial-gradient(1200px 800px at 20% -10%, #112233 0%, #0b0f14 50%, #0b0f14 100%), #0b0f14;
      font-family: system-ui, Segoe UI, Roboto, sans-serif;
    }
    .container { max-width: 1200px; margin: 36px auto; padding: 0 16px; }
    h1 { margin: 0 0 20px; font-weight: 700; letter-spacing: .2px; }

    .panel {
      background: var(--card); border: 1px solid rgba(255,255,255,0.08);
      border-radius: 14px; padding: 16px; margin-bottom: 16px;
    }

    .grid-2 {
      display: grid; grid-template-columns: 1fr 1fr; gap: 16px;
    }

    label { user-select: none; cursor: pointer; }
    input[type="text"]{
      width: 100%; padding: 12px 12px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06); color: var(--text); font-size: 15px;
      outline: none;
    }
    input[type="checkbox"] { transform: translateY(1px); }

    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    .muted { color: var(--muted); font-size: 14px; }

    table { width: 100%; border-collapse: collapse; overflow: hidden; border-radius: 12px; }
    thead th {
      background: rgba(0,191,255,0.28); padding: 10px; text-align: center; font-weight: 700;
      border-bottom: 1px solid rgba(255,255,255,0.08);
    }
    tbody td { padding: 10px; text-align: center; border-bottom: 1px solid rgba(255,255,255,0.06); font-size: 14px; }
    tfoot td { padding: 10px; font-weight: 700; background: rgba(255,255,255,0.07); }
    tr:nth-child(even) td { background: rgba(255,255,255,0.03); }

    .highlight-yellow { background: var(--warn1) !important; }
    .highlight-red { background: var(--warn2) !important; }
    .highlight-blue { background: var(--hl) !important; }
    .highlight-ghost { background: var(--ghost) !important; }

    .dropdown {
      background: var(--card); border: 1px solid rgba(255,255,255,0.12);
      border-radius: 10px; padding: 6px; max-height: 320px; overflow-y: auto; display: none; margin-top: 6px;
    }
    .dropdown-item {
      display: flex; align-items: center; justify-content: space-between;
      gap: 12px; padding: 8px 10px; border-radius: 8px; cursor: pointer;
    }
    .dropdown-item:hover { background: rgba(255,255,255,0.06); }
    .pill { background: goldenrod; color: black; padding: 2px 8px; border-radius: 999px; font-weight: 700; font-size: 12px; }

    .volume { display: grid; grid-template-columns: 1fr 1fr; gap: 8px 24px; }
    .volume strong { font-weight: 700; }
    .spread { margin-top: 10px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.15); }

    @media (max-width: 920px) { .grid-2 { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <div class="container">
    <h1>Bazaar Orders</h1>

    <div class="panel">
      <div class="volume" id="volumeBox">
        <!-- Filled dynamically -->
      </div>
      <div class="spread" id="spreadBox"></div>
    </div>

    <div class="panel">
      <div class="row">
        <div style="flex: 1 1 320px; min-width: 280px;">
          <label>Item ID</label>
          <input id="itemInput" type="text" placeholder="Enter Item ID (e.g., BOOSTER_COOKIE)"/>
          <div id="itemDropdown" class="dropdown"></div>
          <div class="muted" id="chartLink" style="margin-top:6px;"></div>
        </div>
        <div style="flex: 1 1 260px; min-width: 260px;">
          <label>Track Order By Price</label>
          <input id="trackInput" type="text" placeholder="Enter price to track"/>
          <label class="muted" style="display:block; margin-top:6px;">
            <input id="groupToggle" type="checkbox"/> Group prices within ±0.15%
          </label>
        </div>
      </div>
      <div class="muted" style="margin-top:8px;">Tip: DevTools → Application → Local Storage to inspect remembered orders.</div>
    </div>

    <div id="orderInfo" class="panel" style="display:none;"></div>

    <div class="grid-2">
      <div class="panel">
        <h2 style="margin:0 0 10px;">Buy Orders (expensive → cheapest)</h2>
        <table id="buyTable">
          <thead><tr><th>Orders</th><th>Amount</th><th>Unit Price</th><th>Coin Equivalent</th></tr></thead>
          <tbody></tbody>
          <tfoot><tr><td>Total:</td><td></td><td></td><td></td></tr></tfoot>
        </table>
      </div>
      <div class="panel">
        <h2 style="margin:0 0 10px;">Sell Orders (cheapest → expensive)</h2>
        <table id="sellTable">
          <thead><tr><th>Orders</th><th>Amount</th><th>Unit Price</th><th>Coin Equivalent</th></tr></thead>
          <tbody></tbody>
          <tfoot><tr><td>Total:</td><td></td><td></td><td></td></tr></tfoot>
        </table>
      </div>
    </div>
  </div>

  <script type="module">
    // ---------- Config ----------
    const GROUP_PCT = 0.15; // ±0.15% grouping tolerance

    async function getApiKey() {
      // If you have a key, return it here. The endpoint works without a key for public reads too.
      return ""; // "YOUR_API_KEY_HERE"
    }

    // ---------- Elements ----------
    const itemInput  = document.getElementById("itemInput");
    const itemDropdown = document.getElementById("itemDropdown");
    const chartLink  = document.getElementById("chartLink");
    const trackInput = document.getElementById("trackInput");
    const groupToggle = document.getElementById("groupToggle");

    const buyBody  = document.querySelector("#buyTable tbody");
    const sellBody = document.querySelector("#sellTable tbody");
    const buyFoot  = document.querySelector("#buyTable tfoot tr");
    const sellFoot = document.querySelector("#sellTable tfoot tr");

    const orderInfo = document.getElementById("orderInfo");
    const volumeBox = document.getElementById("volumeBox");
    const spreadBox = document.getElementById("spreadBox");

    // ---------- State ----------
    let currentItemId = "";
    let allItems = [];
    let latestBuySummary = [];  // API sell_summary (sell offers)  -> Buy table
    let latestSellSummary = []; // API buy_summary  (buy bids)     -> Sell table
    let lastHourlyBuyVolume  = 0; // for Buy (uses instasells)
    let lastHourlySellVolume = 0; // for Sell (uses instabuys)
    let useGrouping = false;

    // ---------- Helpers ----------
    function approxEqual(a,b,eps=1e-6){ return Math.abs(a-b) <= eps; }
    function storageKey(itemId, side){ return `remembered:${itemId}:${side}`; }
    function readRemembered(itemId, side){
      try { return JSON.parse(localStorage.getItem(storageKey(itemId,side)) || "[]"); } catch { return []; }
    }
    function writeRemembered(itemId, side, arr){
      try { localStorage.setItem(storageKey(itemId,side), JSON.stringify(arr)); } catch {}
    }
    function addOrUpdateRemembered(itemId, side, price, amount){
      const arr = readRemembered(itemId, side);
      const i = arr.findIndex(r => approxEqual(r.price, price));
      if (i>=0){ arr[i].amount = amount; arr[i].ts = Date.now(); }
      else { arr.push({ price, amount, ts: Date.now() }); }
      writeRemembered(itemId, side, arr);
    }
    function removeRemembered(itemId, side, price){
      writeRemembered(itemId, side, readRemembered(itemId, side).filter(r => !approxEqual(r.price, price)));
    }

    function groupSummary(summary, pct = GROUP_PCT) {
      if (!Array.isArray(summary) || summary.length === 0) return [];
      const tol = pct / 100;
      const arr = [...summary]; // preserve incoming order
      const out = [];
      let cur = null;
      const pushCur = () => { if (cur){ delete cur._coins; out.push(cur); } };
      for (const row of arr) {
        const base = { ...row, _coins: row.amount * row.pricePerUnit };
        if (!cur) { cur = base; continue; }
        const rel = Math.abs(row.pricePerUnit - cur.pricePerUnit) / (cur.pricePerUnit || 1);
        if (rel <= tol) {
          cur.orders += row.orders;
          cur.amount += row.amount;
          cur._coins += row.amount * row.pricePerUnit;
          cur.pricePerUnit = cur._coins / cur.amount;
          if (row.ghost || cur.ghost) cur.ghost = true;
        } else {
          pushCur();
          cur = base;
        }
      }
      pushCur();
      return out;
    }

    function mergeRememberedIntoDisplay(apiSellSummary, apiBuySummary) {
      const buyGhosts = readRemembered(currentItemId, "buy")
        .filter(r => apiSellSummary.findIndex(x => approxEqual(x.pricePerUnit, r.price)) === -1)
        .map(r => ({ orders: 1, amount: r.amount || 0, pricePerUnit: r.price, ghost: true }));
      const sellGhosts = readRemembered(currentItemId, "sell")
        .filter(r => apiBuySummary.findIndex(x => approxEqual(x.pricePerUnit, r.price)) === -1)
        .map(r => ({ orders: 1, amount: r.amount || 0, pricePerUnit: r.price, ghost: true }));

      // Combine
      let buyCombined  = [...apiSellSummary, ...buyGhosts];
      let sellCombined = [...apiBuySummary, ...sellGhosts];

      // Apply grouping (optional) BEFORE final sorting; ghost flag is preserved/propagated
      if (useGrouping) {
        buyCombined  = groupSummary(buyCombined);
        sellCombined = groupSummary(sellCombined);
      }

      // Final sort: ghosts last
      buyCombined.sort((a,b)=>{
        if (!!a.ghost !== !!b.ghost) return a.ghost ? 1 : -1; // ghosts last
        return b.pricePerUnit - a.pricePerUnit; // DESC for Buy
      });
      sellCombined.sort((a,b)=>{
        if (!!a.ghost !== !!b.ghost) return a.ghost ? 1 : -1; // ghosts last
        return a.pricePerUnit - b.pricePerUnit; // ASC for Sell
      });

      return { buyDisplay: buyCombined, sellDisplay: sellCombined };
    }

    function averageAmount(summary){
      if (!summary.length) return 0;
      return summary.reduce((s,r)=>s+r.amount,0) / summary.length;
    }

    function renderTable(summary, tbody, tfootRow, hourlyVolume){
      tbody.innerHTML = "";
      let totalAmount=0, totalCoins=0;
      for (const row of summary) {
        const total = row.amount * row.pricePerUnit;
        totalAmount += row.amount; totalCoins += total;
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${row.orders}</td>
          <td>${row.amount}</td>
          <td>${row.pricePerUnit.toLocaleString()} coins</td>
          <td>${total.toLocaleString()} coins</td>
        `;
        if (row.ghost) tr.classList.add("highlight-ghost");
        else {
          if (row.amount > hourlyVolume * 5) tr.classList.add("highlight-red");
          else if (row.amount > hourlyVolume) tr.classList.add("highlight-yellow");
        }
        tbody.appendChild(tr);
      }
      tfootRow.innerHTML = `
        <td>Total:</td>
        <td>${totalAmount}</td>
        <td></td>
        <td>${totalCoins.toLocaleString()} coins</td>
      `;
    }

    function renderCurrentTables() {
      // Start from raw API arrays
      let apiSell = [...latestBuySummary];   // sell_summary -> Buy table
      let apiBuy  = [...latestSellSummary];  // buy_summary  -> Sell table

      // For remembering decisions (top 13), we sort API-only ladders in the correct directions
      const buySortedDesc = [...apiSell].sort((a,b)=> b.pricePerUnit - a.pricePerUnit);
      const sellSortedAsc = [...apiBuy].sort((a,b)=> a.pricePerUnit - b.pricePerUnit);

      // Build displays with ghosts + grouping + final sort
      const { buyDisplay, sellDisplay } = mergeRememberedIntoDisplay(apiSell, apiBuy);

      renderTable(buyDisplay,  buyBody,  buyFoot,  lastHourlyBuyVolume);
      renderTable(sellDisplay, sellBody, sellFoot, lastHourlySellVolume);

      // Tracking highlight
      const tracked = parseFloat((trackInput.value || "").replace(/,/g, ''));
      highlightTrackedOrder(tracked, buyDisplay, sellDisplay);
    }

    function highlightTrackedOrder(price, buyShown, sellShown){
      orderInfo.style.display = "none";
      orderInfo.innerHTML = "";
      if (!price || isNaN(price)) return;

      // Clear previous
      [...buyBody.children, ...sellBody.children].forEach(r => r.classList.remove("highlight-blue"));

      for (const [summary, body] of [[buyShown, buyBody], [sellShown, sellBody]]) {
        let coinsBetween=0, itemsBetween=0, priority=1;
        for (let i=0;i<summary.length;i++){
          const row = summary[i];
          const unit = parseFloat(row.pricePerUnit.toFixed(1));
          if (Math.abs(unit - price) < 0.1) {
            const tr = body.children[i];
            if (tr) tr.classList.add("highlight-blue");
            orderInfo.style.display = "block";
            orderInfo.innerHTML = `
              <strong>Tracked Order Info</strong><br/>
              Priority position: ${priority}<br/>
              Items between: ${itemsBetween}<br/>
              Coin gap: ${Math.round(coinsBetween).toLocaleString()} coins<br/>
              Items left in order: ${row.amount}
            `;
            return;
          }
          itemsBetween += row.amount;
          coinsBetween += row.amount * row.pricePerUnit;
          priority++;
        }
      }
    }

    function updateRememberedWithCurrent(apiSellSummary, apiBuySummary) {
      // Build API-only ladders in the desired directions
      const buySortedDesc = [...apiSellSummary].sort((a,b)=> b.pricePerUnit - a.pricePerUnit); // Buy table
      const sellSortedAsc = [...apiBuySummary].sort((a,b)=> a.pricePerUnit - b.pricePerUnit);  // Sell table

      const bestSell = buySortedDesc[0]?.pricePerUnit;
      const bestBuy  = sellSortedAsc[0]?.pricePerUnit;

      // Remember positions >=13 within API top-30
      buySortedDesc.slice(13, 30).forEach(r => addOrUpdateRemembered(currentItemId, "buy",  r.pricePerUnit, r.amount));
      sellSortedAsc.slice(13, 30).forEach(r => addOrUpdateRemembered(currentItemId, "sell", r.pricePerUnit, r.amount));

      // Clean remembered per rules
      for (const side of ["buy","sell"]) {
        const apiNow = (side==="buy") ? buySortedDesc : sellSortedAsc;
        const oppNow = (side==="buy") ? sellSortedAsc : buySortedDesc;

        const arr = readRemembered(currentItemId, side);
        const kept = [];

        for (const rec of arr) {
          const p = rec.price;

          // Re-entered top 13?
          const pos = apiNow.findIndex(x => approxEqual(x.pricePerUnit, p));
          if (pos >= 0 && pos <= 12) continue; // drop

          // Canceled: no exact match AND strictly between two levels
          if (pos === -1) {
            const levels = apiNow.map(x => x.pricePerUnit);
            for (let i=0;i<levels.length-1;i++){
              const a = levels[i], b = levels[i+1];
              const lo = Math.min(a,b), hi = Math.max(a,b);
              if (p > lo && p < hi) { // vanished between -> cancel
                rec._drop_reason = "canceled";
                p; // noop
                continue; // drop
              }
            }
          }

          // Filled: opposite best crossed
          if (side==="buy" && typeof bestBuy === "number" && bestBuy >= p) continue;   // buy bids moved up past our sell offer price
          if (side==="sell"&& typeof bestSell=== "number" && bestSell<= p) continue;   // sell offers moved down past our buy bid price

          kept.push(rec);
        }

        writeRemembered(currentItemId, side, kept);
      }
    }

    async function loadData(itemId){
      const key = await getApiKey();
      const url = key ? `https://api.hypixel.net/skyblock/bazaar?key=${key}` : `https://api.hypixel.net/skyblock/bazaar`;
      const res = await fetch(url);
      const json = await res.json();
      const data = json.products?.[itemId];
      if (!data) return;

      const avgInstabuys  = data.quick_status.buyMovingWeek  / 168;
      const avgInstasells = data.quick_status.sellMovingWeek / 168;

      latestBuySummary  = data.sell_summary ?? []; // sell offers
      latestSellSummary = data.buy_summary  ?? []; // buy bids

      lastHourlyBuyVolume  = avgInstasells;
      lastHourlySellVolume = avgInstabuys;

      // Volume / spread box
      const avgSellOrder = averageAmount(latestBuySummary);
      const avgBuyOrder  = averageAmount(latestSellSummary);
      volumeBox.innerHTML = `
        <div><strong>Avg instabuys/hour:</strong> ${avgInstabuys.toFixed(1)}</div>
        <div><strong>Avg instasells/hour:</strong> ${avgInstasells.toFixed(1)}</div>
        <div><strong>Avg sell-order amount:</strong> ${avgSellOrder.toFixed(1)}</div>
        <div><strong>Avg buy-order amount:</strong> ${avgBuyOrder.toFixed(1)}</div>
      `;
      const sellPrice = latestBuySummary[0]?.pricePerUnit || 1;
      const buyPrice  = latestSellSummary[0]?.pricePerUnit || 1;
      const spreadPct = ((buyPrice - sellPrice) / sellPrice) * 100;
      spreadBox.innerHTML = `<strong>Market spread:</strong> ${isFinite(spreadPct) ? spreadPct.toFixed(2)+'%' : 'N/A'}`;

      // Update remembered sets using current API ladders
      updateRememberedWithCurrent(latestBuySummary, latestSellSummary);

      // Render
      renderCurrentTables();
    }

    // ---------- Search / UI ----------
    itemInput.addEventListener("input", () => {
      const query = itemInput.value.trim().toLowerCase();
      itemDropdown.innerHTML = "";
      if (!query) return (itemDropdown.style.display = "none");

      // Lazy search: if we haven't fetched all items yet, do so quickly from current API snapshot
      if (allItems.length === 0) { fetchAllItems().then(() => populateDropdown(query)); }
      else { populateDropdown(query); }
    });

    function populateDropdown(query){
      const filtered = allItems.filter(i => i.name.toLowerCase().includes(query) || i.id.toLowerCase().includes(query));
      for (const item of filtered.slice(0, 60)) {
        const div = document.createElement("div");
        div.className = "dropdown-item";
        div.innerHTML = `<div>${item.name}</div><div class="pill">${item.price} /bz</div>`;
        div.onclick = () => {
          itemInput.value = item.id;
          itemDropdown.style.display = "none";
          selectItem(item.id);
        };
        itemDropdown.appendChild(div);
      }
      itemDropdown.style.display = filtered.length ? "block" : "none";
    }

    function selectItem(id){
      currentItemId = id;
      chartLink.innerHTML = `Chart: <a href="https://skyblock.finance/items/${id}/chart" target="_blank" style="color:var(--accent);">skyblock.finance/items/${id}/chart</a>`;
      loadData(id);

      const url = new URL(window.location);
      url.searchParams.set("item", id);
      history.replaceState({}, "", url);
    }

    trackInput.addEventListener("change", () => {
      const tracked = parseFloat((trackInput.value||"").replace(/,/g,''));
      // Re-highlight against the current DOM
      const { buyDisplay, sellDisplay } = mergeRememberedIntoDisplay(latestBuySummary, latestSellSummary);
      highlightTrackedOrder(tracked, buyDisplay, sellDisplay);
    });

    groupToggle.addEventListener("change", () => {
      useGrouping = groupToggle.checked;
      renderCurrentTables();
    });

    async function fetchAllItems(){
      const key = await getApiKey();
      const url = key ? `https://api.hypixel.net/skyblock/bazaar?key=${key}` : `https://api.hypixel.net/skyblock/bazaar`;
      const res = await fetch(url);
      const json = await res.json();
      const products = json.products || {};
      allItems = Object.keys(products).map(id => {
        const q = products[id].quick_status;
        const price = q.sellPrice > 1e6 ? (q.sellPrice/1e6).toFixed(2)+'M' :
                      q.sellPrice > 1e3 ? (q.sellPrice/1e3).toFixed(1)+'k' :
                      q.sellPrice.toFixed(1);
        return { id, name: id.replace(/_/g,' ').toLowerCase().replace(/\b\w/g,c=>c.toUpperCase()), price };
      });
    }

    // Preload from URL if present
    const urlParams = new URLSearchParams(location.search);
    const preItem = urlParams.get("item");
    const preTrack = urlParams.get("track");
    if (preItem) {
      itemInput.value = preItem;
      selectItem(preItem);
    }
    if (preTrack) trackInput.value = preTrack;

    // Polling
    setInterval(() => { if (currentItemId) loadData(currentItemId); }, 3000);

    // bootstrap quick index list in the background
    fetchAllItems();
  </script>
</body>
</html>
