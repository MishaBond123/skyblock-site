<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Bazaar Orders — Ghost Levels (ENHANCED)</title>
  <link rel="icon" type="image/jpeg" href="site-icon.png"/>

  <style>
    :root {
      --card: rgba(0,0,0,0.65);
      --text: #f5f7fa;
      --muted: rgba(255,255,255,0.75);
      --accent: #00bfff;
      --ghost: rgba(186,114,255,0.18);
      --warn1: rgba(255,255,0,0.15);
      --warn2: rgba(255,80,80,0.25);
      --hl: rgba(0,191,255,0.25);
      --border: rgba(255,255,255,0.12);
      --head: rgba(0,191,255,0.28);
      --up: #27d17f;
      --down: #ff5f5f;
      --neutral: #a3b1c6;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; color: var(--text);
      background-image: url('bgimage.jpeg');
      background-size: cover;
      background-attachment: fixed;
      background-position: center;
      font-family: system-ui, Segoe UI, Roboto, sans-serif;
    }
    .container { max-width: 1280px; margin: 36px auto; padding: 0 16px; }
    h1 { margin: 0 0 20px; font-weight: 800; letter-spacing: .2px; }

    .panel {
      background: var(--card); border: 1px solid var(--border);
      border-radius: 16px; padding: 16px; margin-bottom: 16px;
      backdrop-filter: saturate(120%) blur(2px);
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
    }

    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    @media (max-width: 1024px) { .grid-2 { grid-template-columns: 1fr; } }

    label { user-select: none; cursor: pointer; display: block; margin-bottom: 6px; }
    input[type="text"]{
      width: 100%; padding: 12px 12px; border-radius: 12px; border: 1px solid var(--border);
      background: rgba(255,255,255,0.06); color: var(--text); font-size: 15px; outline: none;
    }
    input[type="checkbox"] { transform: translateY(1px); }
    .row { display: flex; gap: 16px; align-items: stretch; flex-wrap: wrap; }
    .muted { color: var(--muted); font-size: 14px; }

    table { width: 100%; border-collapse: collapse; overflow: hidden; border-radius: 12px; }
    thead th {
      background: var(--head); padding: 10px; text-align: center; font-weight: 700;
      border-bottom: 1px solid var(--border);
    }
    tbody td { padding: 10px; text-align: center; border-bottom: 1px solid rgba(255,255,255,0.06); font-size: 14px; }
    tfoot td { padding: 10px; font-weight: 700; background: rgba(255,255,255,0.07); }
    tr:nth-child(even) td { background: rgba(255,255,255,0.03); }

    .highlight-yellow { background: var(--warn1) !important; }
    .highlight-red    { background: var(--warn2) !important; }
    .highlight-blue   { background: var(--hl) !important; }
    .highlight-ghost  { background: var(--ghost) !important; }

    .dropdown {
      background: var(--card); border: 1px solid var(--border);
      border-radius: 12px; padding: 6px; max-height: 340px; overflow-y: auto; display: none; margin-top: 6px;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
    }
    .dropdown-item {
      display: flex; align-items: center; justify-content: space-between;
      gap: 12px; padding: 10px 12px; border-radius: 10px; cursor: pointer; transition: background .15s;
    }
    .dropdown-item:hover { background: rgba(255,255,255,0.06); }
    .pill { background: goldenrod; color: black; padding: 2px 8px; border-radius: 999px; font-weight: 700; font-size: 12px; }

    .stats {
      display: grid; grid-template-columns: repeat(4, minmax(160px, 1fr)); gap: 12px;
    }
    @media (max-width: 1024px) { .stats { grid-template-columns: repeat(2, 1fr); } }
    @media (max-width: 520px)  { .stats { grid-template-columns: 1fr; } }
    .stat {
      background: rgba(255,255,255,0.06); border: 1px solid var(--border); border-radius: 12px; padding: 12px;
    }
    .stat-label { font-size: 12px; color: var(--muted); text-transform: uppercase; letter-spacing: .6px; }
    .stat-value { font-size: 18px; font-weight: 800; display: flex; align-items: center; gap: 8px; }
    .delta { font-size: 12px; font-weight: 700; padding: 2px 6px; border-radius: 999px; background: rgba(255,255,255,0.08); }
    .delta-up { color: var(--up); }
    .delta-down { color: var(--down); }
    .delta-flat { color: var(--neutral); }

    .kicker { display:flex; align-items:center; justify-content:space-between; gap:12px; }
    .badge { font-size:12px; background:rgba(255,255,255,0.08); border:1px solid var(--border); padding:4px 8px; border-radius:999px; }
  </style>
</head>
<body>
  <div class="container">
    <div class="kicker">
      <h1>Bazaar Orders</h1>
      <div class="muted" id="lastUpdated">—</div>
    </div>

    <div class="panel">
      <div id="topStats" class="stats"></div>
    </div>

    <div class="panel">
      <div class="row">
        <div style="flex:1 1 420px; min-width:280px;">
          <label>Item ID</label>
          <input id="itemInput" type="text" placeholder="Enter Item ID (e.g., BOOSTER_COOKIE)"/>
          <div id="itemDropdown" class="dropdown"></div>
          <div class="muted" id="chartLink" style="margin-top:6px;"></div>
        </div>
        <div style="flex:1 1 360px; min-width:260px;">
          <label>Track Order By Price</label>
          <input id="trackInput" type="text" placeholder="Enter price to track"/>
          <label class="muted" style="margin-top:6px;"><input id="groupToggle" type="checkbox"/> Group live prices within ±0.15%</label>
          <div class="muted" style="margin-top:6px;">
            <span class="badge">Ghosts = remembered price levels (0.1 precision) below live orders</span>
          </div>
        </div>
      </div>
    </div>

    <div id="orderInfo" class="panel" style="display:none;"></div>

    <div class="grid-2">
      <div class="panel">
        <h2 style="margin:0 0 10px;">Buy Orders (expensive → cheapest)</h2>
        <table id="buyTable">
          <thead><tr><th>Orders</th><th>Amount</th><th>Unit Price</th><th>Coin Equivalent</th></tr></thead>
          <tbody></tbody>
          <tfoot><tr><td>Total:</td><td></td><td></td><td></td></tr></tfoot>
        </table>
      </div>
      <div class="panel">
        <h2 style="margin:0 0 10px;">Sell Orders (cheapest → expensive)</h2>
        <table id="sellTable">
          <thead><tr><th>Orders</th><th>Amount</th><th>Unit Price</th><th>Coin Equivalent</th></tr></thead>
          <tbody></tbody>
          <tfoot><tr><td>Total:</td><td></td><td></td><td></td></tr></tfoot>
        </table>
      </div>
    </div>
  </div>

  <script type="module">
const GROUP_PCT = 0.15;
// Change this if you like; deltas now persist between polls.
const POLL_MS = 3000;

const itemInput  = document.getElementById("itemInput");
const itemDropdown = document.getElementById("itemDropdown");
const chartLink  = document.getElementById("chartLink");
const trackInput = document.getElementById("trackInput");
const groupToggle = document.getElementById("groupToggle");
const lastUpdated = document.getElementById("lastUpdated");

const topStats = document.getElementById("topStats");

const buyBody  = document.querySelector("#buyTable tbody");
const sellBody = document.querySelector("#sellTable tbody");
const buyFoot  = document.querySelector("#buyTable tfoot tr");
const sellFoot = document.querySelector("#sellTable tfoot tr");

const orderInfo = document.getElementById("orderInfo");

let currentItemId = "";
let allItems = [];

// asks = sell orders; bids = buy orders
let asksSummary = [];
let bidsSummary = [];

let avgInstabuysPerHr  = 0; // buyMovingWeek/168
let avgInstasellsPerHr = 0; // sellMovingWeek/168
let useGrouping = false;

let prevAsksDesc = [];
let prevBidsAsc = [];

// Persisted metrics for deltas (value + last rendered delta)
const prevMetrics = new Map();

// Tolerances for “unchanged”
const REL_EPS = 1e-7; // 0.0001% relative tolerance (robust for big numbers)

const fmt = {
  coins(n){ if (!isFinite(n)) return '—'; return Math.round(n).toLocaleString(); },
  price(n){ if (!isFinite(n)) return '—'; return `${n.toLocaleString()} coins`; },
  sig(n, s=6){ if (!isFinite(n)) return '—'; return Number(n).toPrecision(s); },
  pct(n, s=2){ if (!isFinite(n)) return '—'; return `${Math.abs(Number(n).toFixed(s))}%`; },
};

function nearlyEqual(a,b){
  if (!isFinite(a) || !isFinite(b)) return a === b;
  const denom = Math.max(1, Math.abs(a), Math.abs(b));
  return Math.abs(a - b) / denom <= REL_EPS;
}

// ---------- Helpers ----------
function keyPrice(p){ return Math.round(p * 10) / 10; }
function sameLevel(a, b){ return keyPrice(a) === keyPrice(b); }
function storageKey(itemId, side){ return `remembered:${itemId}:${side}`; }
function readRemembered(itemId, side){ try { return JSON.parse(localStorage.getItem(storageKey(itemId,side)) || "[]"); } catch { return []; } }
function writeRemembered(itemId, side, arr){ try { localStorage.setItem(storageKey(itemId,side), JSON.stringify(arr)); } catch {} }

function addGhost(itemId, side, price, amount, orders){
  const arr = readRemembered(itemId, side);
  const k = keyPrice(price);
  if (!arr.some(x => sameLevel(x.price, k))) {
    arr.push({ price: k, amount: amount ?? 0, orders: orders ?? 1, ts: Date.now() });
    writeRemembered(itemId, side, arr);
  }
}

function crossed(side, price, bestBid, bestAsk){
  const EPS = 1e-9;
  return side==="buy" ? price >= bestAsk - EPS : price <= bestBid + EPS;
}

function safeMinPrice(arr){ return arr.length ? Math.min(...arr.map(r=>r.pricePerUnit)) : Infinity; }
function safeMaxPrice(arr){ return arr.length ? Math.max(...arr.map(r=>r.pricePerUnit)) : -Infinity; }

// Group within ±pct of the running anchor
function groupSummary(summary, pct = GROUP_PCT) {
  if (!Array.isArray(summary) || summary.length === 0) return [];
  const tol = pct / 100;
  const arr = [...summary];
  const out = [];
  let cur = null;
  const pushCur = () => { if (cur){ delete cur._coins; out.push(cur); } };
  for (const row of arr) {
    const base = { ...row, _coins: row.amount * row.pricePerUnit };
    if (!cur) { cur = base; continue; }
    const rel = Math.abs(row.pricePerUnit - cur.pricePerUnit) / (cur.pricePerUnit || 1);
    if (rel <= tol) {
      cur.orders += row.orders;
      cur.amount += row.amount;
      cur._coins += row.amount * row.pricePerUnit;
      cur.pricePerUnit = cur._coins / cur.amount;
    } else { pushCur(); cur = base; }
  }
  pushCur();
  return out;
}

// Build table displays (bids on left, asks on right), ghosts appended after live
function buildDisplaysWithGhosts(asks, bids) {
  const buyGhosts = readRemembered(currentItemId, "buy")
    .filter(r => !bids.some(x => sameLevel(x.pricePerUnit, r.price)))
    .map(r => ({ orders: r.orders ?? 1, amount: r.amount ?? 0, pricePerUnit: keyPrice(r.price), ghost: true }));

  const sellGhosts = readRemembered(currentItemId, "sell")
    .filter(r => !asks.some(x => sameLevel(x.pricePerUnit, r.price)))
    .map(r => ({ orders: r.orders ?? 1, amount: r.amount ?? 0, pricePerUnit: keyPrice(r.price), ghost: true }));

  const bidsGrouped = useGrouping ? groupSummary(bids) : [...bids];
  const asksGrouped = useGrouping ? groupSummary(asks) : [...asks];

  const buyCombined  = [...bidsGrouped, ...buyGhosts].sort((a,b)=>{
    if (!!a.ghost !== !!b.ghost) return a.ghost ? 1 : -1;
    return b.pricePerUnit - a.pricePerUnit; // bids high→low
  });

  const sellCombined = [...asksGrouped, ...sellGhosts].sort((a,b)=>{
    if (!!a.ghost !== !!b.ghost) return a.ghost ? 1 : -1;
    return a.pricePerUnit - b.pricePerUnit; // asks low→high
  });

  return { buyDisplay: buyCombined, sellDisplay: sellCombined };
}

function renderTable(summary, tbody, tfootRow, hourlyVolume){
  tbody.innerHTML = "";
  let totalAmount=0, totalCoins=0;
  for (const row of summary) {
    const total = row.amount * row.pricePerUnit;
    totalAmount += row.amount; totalCoins += total;
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${row.orders}</td>
      <td>${row.amount}</td>
      <td>${row.pricePerUnit.toLocaleString()} coins</td>
      <td>${Math.round(total).toLocaleString()} coins</td>
    `;
    if (row.ghost) tr.classList.add("highlight-ghost");
    else {
      if (row.amount > hourlyVolume * 5) tr.classList.add("highlight-red");
      else if (row.amount > hourlyVolume) tr.classList.add("highlight-yellow");
    }
    tbody.appendChild(tr);
  }
  tfootRow.innerHTML = `
    <td>Total:</td>
    <td>${totalAmount}</td>
    <td></td>
    <td>${Math.round(totalCoins).toLocaleString()} coins</td>
  `;
}

function renderCurrentTables() {
  const { buyDisplay, sellDisplay } = buildDisplaysWithGhosts(asksSummary, bidsSummary);
  renderTable(buyDisplay,  buyBody,  buyFoot,  avgInstabuysPerHr);
  renderTable(sellDisplay, sellBody, sellFoot, avgInstasellsPerHr);
  const tracked = parseFloat((trackInput.value || "").replace(/,/g, ''));
  highlightTrackedOrder(tracked, buyDisplay, sellDisplay);
}

function highlightTrackedOrder(price, buyShown, sellShown){
  orderInfo.style.display = "none";
  orderInfo.innerHTML = "";
  if (!price || isNaN(price)) return;
  [...buyBody.children, ...sellBody.children].forEach(r => r.classList.remove("highlight-blue"));
  for (const [summary, body] of [[buyShown, buyBody], [sellShown, sellBody]]) {
    let coinsBetween=0, itemsBetween=0, priority=1;
    for (let i=0;i<summary.length;i++){
      const row = summary[i];
      const unit = parseFloat(keyPrice(row.pricePerUnit).toFixed(1));
      if (Math.abs(unit - price) < 0.1) {
        const tr = body.children[i];
        if (tr) tr.classList.add("highlight-blue");
        orderInfo.style.display = "block";
        orderInfo.innerHTML = `
          <strong>Tracked Order Info</strong><br/>
          Priority position: ${priority}<br/>
          Items between: ${itemsBetween}<br/>
          Coin gap: ${Math.round(coinsBetween).toLocaleString()} coins<br/>
          Items left in order: ${row.amount}
        `;
        return;
      }
      itemsBetween += row.amount;
      coinsBetween += row.amount * row.pricePerUnit;
      priority++;
    }
  }
}

function rememberVanishedOutsideTop13(curAsksDesc, curBidsAsc) {
  const curAskKeys  = new Set(curAsksDesc.map(r => keyPrice(r.pricePerUnit)));
  const curBidKeys  = new Set(curBidsAsc.map(r  => keyPrice(r.pricePerUnit)));
  prevAsksDesc.forEach((r, idx) => {
    if (idx >= 13) {
      const k = keyPrice(r.pricePerUnit);
      if (!curAskKeys.has(k)) addGhost(currentItemId, "sell", k, r.amount, r.orders);
    }
  });
  prevBidsAsc.forEach((r, idx) => {
    if (idx >= 13) {
      const k = keyPrice(r.pricePerUnit);
      if (!curBidKeys.has(k)) addGhost(currentItemId, "buy", k, r.amount, r.orders);
    }
  });
}

function cleanGhostsAgainstCurrent(curAsksDesc, curBidsAsc) {
  const askLevels  = curAsksDesc.map(r => keyPrice(r.pricePerUnit));
  const bidLevels  = curBidsAsc.map(r  => keyPrice(r.pricePerUnit));
  const bestAsk = safeMinPrice(curAsksDesc);
  const bestBid = safeMaxPrice(curBidsAsc);
  // sell ghosts
  let keptSell = [];
  for (const g of readRemembered(currentItemId, "sell")) {
    const k = keyPrice(g.price);
    if (askLevels.includes(k)) continue;
    if (crossed("sell", k, bestBid, bestAsk)) continue;
    keptSell.push(g);
  }
  writeRemembered(currentItemId, "sell", keptSell);
  // buy ghosts
  let keptBuy = [];
  for (const g of readRemembered(currentItemId, "buy")) {
    const k = keyPrice(g.price);
    if (bidLevels.includes(k)) continue;
    if (crossed("buy", k, bestBid, bestAsk)) continue;
    keptBuy.push(g);
  }
  writeRemembered(currentItemId, "buy", keptBuy);
}

// ---------- Persistent deltas (no 0% reset between polls) ----------
function deltaSpan(key, newVal){
  const rec = prevMetrics.get(key);
  // If we have a previous reading and *effectively* nothing changed, reuse old delta
  if (rec && isFinite(newVal) && isFinite(rec.val) && nearlyEqual(newVal, rec.val)) {
    return rec.deltaHtml || `<span class="delta delta-flat">(—)</span>`;
  }
  // First observation (or invalid numbers): store and show neutral
  if (!rec || !isFinite(newVal) || !isFinite(rec.val)) {
    const html = `<span class="delta delta-flat">(—)</span>`;
    prevMetrics.set(key, { val: newVal, deltaHtml: html });
    return html;
  }
  // Compute percent change vs previous value and persist it until the value changes again
  const diffPct = ((newVal - rec.val) / (Math.abs(rec.val) || 1)) * 100;
  const cls = Math.abs(diffPct) < 1e-6 ? 'delta-flat' : (diffPct > 0 ? 'delta-up' : 'delta-down');
  const sign = diffPct > 0 ? '+' : (diffPct < 0 ? '−' : '');
  const html = Math.abs(diffPct) < 1e-6
    ? `<span class="delta ${cls}">(0%)</span>`
    : `<span class="delta ${cls}">(${sign}${Math.abs(diffPct).toFixed(2)}%)</span>`;
  prevMetrics.set(key, { val: newVal, deltaHtml: html });
  return html;
}

function statTile(label, valueHtml){
  return `<div class="stat"><div class="stat-label">${label}</div><div class="stat-value">${valueHtml}</div></div>`;
}

function topLevelAmount(summary, side){
  if (!summary.length) return 0;
  const bestAsk = safeMinPrice(asksSummary);
  const bestBid = safeMaxPrice(bidsSummary);
  const mid = (bestAsk + bestBid) / 2;
  if (!isFinite(mid) || mid <= 0) return 0;

  // Allowed band = ±0.3% around mid
  const band = 0.003;
  const lo = mid * (1 - band);
  const hi = mid * (1 + band);

  // Use keyPrice (0.1 increments)
  const levels = summary.filter(r => {
    const kp = keyPrice(r.pricePerUnit);
    return kp >= lo && kp <= hi;
  });

  return levels.reduce((s, r) => s + r.amount, 0);
}

function depthNotional(bids, asks, pctBand){
  if (!bids.length || !asks.length) return 0;
  const bestAsk = Math.min(...asks.map(r=>r.pricePerUnit));
  const bestBid = Math.max(...bids.map(r=>r.pricePerUnit));
  const mid = (bestAsk + bestBid)/2; if (!isFinite(mid) || mid<=0) return 0;
  const lo = mid*(1 - pctBand/100), hi = mid*(1 + pctBand/100);
  const asksIn = asks.filter(r => r.pricePerUnit >= lo && r.pricePerUnit <= hi).slice(0,20);
  const bidsIn = bids.filter(r => r.pricePerUnit >= lo && r.pricePerUnit <= hi).slice(0,20);
  const notional = asksIn.reduce((s,r)=>s + r.amount*r.pricePerUnit, 0)
                   + bidsIn.reduce((s,r)=>s + r.amount*r.pricePerUnit, 0);
  return notional;
}

function renderTopStats(){
  const bestAsk = safeMinPrice(asksSummary);
  const bestBid = safeMaxPrice(bidsSummary);

  const mid = (bestAsk + bestBid) / 2;
  const spreadCoins = bestAsk - bestBid; // non-negative when sides are correct
  const spreadPct = (isFinite(mid) && mid > 0) ? Math.abs(spreadCoins / mid) * 100 : NaN;

  const avgSellOrder = averageAmount(asksSummary);
  const avgBuyOrder  = averageAmount(bidsSummary);

  topStats.innerHTML = [
    statTile('Best Ask', `${fmt.price(bestAsk)} ${deltaSpan('bestAsk', bestAsk)}`),
    statTile('Best Bid', `${fmt.price(bestBid)} ${deltaSpan('bestBid', bestBid)}`),
    statTile('Mid Price', `${fmt.price(mid)} ${deltaSpan('mid', mid)}`),
    statTile('Spread (coins)', `${fmt.coins(spreadCoins)} coins ${deltaSpan('spreadCoins', spreadCoins)}`),
    statTile('Spread %', `${fmt.pct(spreadPct, 3)} ${deltaSpan('spreadPct', spreadPct)}`),
    statTile('Avg Instabuys / hr', `${fmt.sig(avgInstabuysPerHr, 6)} ${deltaSpan('vBuy', avgInstabuysPerHr)}`),
    statTile('Avg Instasells / hr', `${fmt.sig(avgInstasellsPerHr, 6)} ${deltaSpan('vSell', avgInstasellsPerHr)}`),
    statTile('Avg Sell-Order Amount', `${fmt.sig(avgSellOrder, 6)} ${deltaSpan('avgSellOrder', avgSellOrder)}`),
    statTile('Avg Buy-Order Amount', `${fmt.sig(avgBuyOrder, 6)} ${deltaSpan('avgBuyOrder', avgBuyOrder)}`),
    statTile('Top-of-Book Size (Ask)', `${fmt.coins(topLevelAmount(asksSummary,'ask'))} ${deltaSpan('topAskSize', topLevelAmount(asksSummary,'ask'))}`),
    statTile('Top-of-Book Size (Bid)', `${fmt.coins(topLevelAmount(bidsSummary,'bid'))} ${deltaSpan('topBidSize', topLevelAmount(bidsSummary,'bid'))}`),
    statTile('Depth (±0.5%)', `${fmt.coins(depthNotional(bidsSummary, asksSummary, 0.5))} ${deltaSpan('depth05', depthNotional(bidsSummary, asksSummary, 0.5))}`),
  ].join('');
}

function averageAmount(summary){ if (!summary.length) return 0; return summary.reduce((s,r)=>s+r.amount,0) / summary.length; }

function updateLastUpdated(){
  const d = new Date();
  lastUpdated.textContent = `Updated ${d.toLocaleTimeString()} (every ${Math.round(POLL_MS/1000)}s)`;
}

async function getApiKey(){ return ""; }

// Pick correct sides; swap if spread negative (your rule)
function chooseSides(data){
  const sells = data.sell_summary ?? [];
  const buys  = data.buy_summary  ?? [];

  const askA = safeMinPrice(sells);
  const bidA = safeMaxPrice(buys);
  const spreadA = askA - bidA;

  const askB = safeMinPrice(buys);
  const bidB = safeMaxPrice(sells);
  const spreadB = askB - bidB;

  // Prefer any non-negative spread; break ties by smaller spread
  if (isFinite(spreadA) && spreadA >= 0 && (!isFinite(spreadB) || spreadB < 0 || spreadA <= spreadB)) {
    return { asks: sells, bids: buys };
  }
  if (isFinite(spreadB) && spreadB >= 0) {
    return { asks: buys, bids: sells }; // swapped
  }
  // Fallback: least-wrong pair by |spread|
  return Math.abs(spreadA) <= Math.abs(spreadB)
    ? { asks: sells, bids: buys }
    : { asks: buys,  bids: sells };
}

// -------- Item search ----------
async function fetchAllItems(){
  const key = await getApiKey();
  const url = key ? `https://api.hypixel.net/skyblock/bazaar?key=${key}` : `https://api.hypixel.net/skyblock/bazaar`;
  const res = await fetch(url);
  const json = await res.json();
  const products = json.products || {};
  allItems = Object.keys(products).map(id => {
    const q = products[id].quick_status;
    const price = q.sellPrice > 1e6 ? (q.sellPrice/1e6).toFixed(2)+'M' :
                  q.sellPrice > 1e3 ? (q.sellPrice/1e3).toFixed(1)+'k' :
                  q.sellPrice.toFixed(1);
    return { id, name: id.replace(/_/g,' ').toLowerCase().replace(/\b\w/g,c=>c.toUpperCase()), price };
  });
}

function populateDropdown(query){
  const filtered = allItems.filter(i => i.name.toLowerCase().includes(query) || i.id.toLowerCase().includes(query));
  itemDropdown.innerHTML = "";
  for (const item of filtered.slice(0, 80)) {
    const div = document.createElement("div");
    div.className = "dropdown-item";
    div.innerHTML = `<div>${item.name}</div><div class="pill">${item.price} /bz</div>`;
    div.onclick = () => { itemInput.value = item.id; itemDropdown.style.display = "none"; selectItem(item.id); };
    itemDropdown.appendChild(div);
  }
  itemDropdown.style.display = filtered.length ? "block" : "none";
}

itemInput.addEventListener("input", () => {
  const query = itemInput.value.trim().toLowerCase();
  if (!query) { itemDropdown.style.display = "none"; return; }
  if (allItems.length === 0) { fetchAllItems().then(() => populateDropdown(query)); }
  else { populateDropdown(query); }
});

function selectItem(id){
  currentItemId = id;
  prevAsksDesc = [];
  prevBidsAsc = [];
  prevMetrics.clear(); // reset deltas when switching items
  chartLink.innerHTML = `Chart: <a href="https://skyblock.finance/items/${id}/chart" target="_blank" style="color:var(--accent);">skyblock.finance/items/${id}/chart</a>`;
  loadData(id);
  const url = new URL(window.location);
  url.searchParams.set("item", id);
  history.replaceState({}, "", url);
}

trackInput.addEventListener("change", () => {
  const tracked = parseFloat((trackInput.value||"").replace(/,/g,''));
  const { buyDisplay, sellDisplay } = buildDisplaysWithGhosts(asksSummary, bidsSummary);
  highlightTrackedOrder(tracked, buyDisplay, sellDisplay);
});

groupToggle.addEventListener("change", () => {
  useGrouping = groupToggle.checked;
  renderCurrentTables();
  renderTopStats();
});

// ------------ Load / Poll ------------
async function loadData(itemId){
  const key = await getApiKey();
  const url = key ? `https://api.hypixel.net/skyblock/bazaar?key=${key}` : `https://api.hypixel.net/skyblock/bazaar`;
  const res = await fetch(url);
  const json = await res.json();
  const data = json.products?.[itemId];
  if (!data) return;

  // Hourly estimates (moving week / 168)
  avgInstabuysPerHr  = data.quick_status.buyMovingWeek  / 168;
  avgInstasellsPerHr = data.quick_status.sellMovingWeek / 168;

  // Side detection (swap if needed)
  const { asks, bids } = chooseSides(data);
  asksSummary = asks ?? [];
  bidsSummary = bids ?? [];

  // Render tables + top stats
  renderCurrentTables();
  renderTopStats();
  updateLastUpdated();

  // For ghost maintenance, create sorted snapshots
  const curAsksDesc = [...asksSummary].sort((a,b)=> b.pricePerUnit - a.pricePerUnit); // asks high→low for sweep-out detection
  const curBidsAsc  = [...bidsSummary].sort((a,b)=> a.pricePerUnit - b.pricePerUnit); // bids low→high
  if (prevAsksDesc.length || prevBidsAsc.length) rememberVanishedOutsideTop13(curAsksDesc, curBidsAsc);
  cleanGhostsAgainstCurrent(curAsksDesc, curBidsAsc);
  prevAsksDesc = curAsksDesc;
  prevBidsAsc  = curBidsAsc;
}

const urlParams = new URLSearchParams(location.search);
const preItem = urlParams.get("item");
const preTrack = urlParams.get("track");
if (preItem) { itemInput.value = preItem; selectItem(preItem); }
if (preTrack) trackInput.value = preTrack;

// One poller only; deltas persist between renders
setInterval(() => { if (currentItemId) loadData(currentItemId); }, POLL_MS);
fetchAllItems();
  </script>
</body>
</html>
