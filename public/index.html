<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Bazaar Orders (WATO)</title>
<link rel="icon" href="site-icon.png"/>
<style>
  :root{--card:rgba(0,0,0,.68);--head:rgba(0,191,255,.28);--text:#f5f7fa;--muted:rgba(255,255,255,.75);--border:rgba(255,255,255,.12)}
  *{box-sizing:border-box}
  body{margin:0;color:var(--text);font-family:system-ui,Segoe UI,Roboto,sans-serif;background:url('bgimage.jpeg') center/cover fixed no-repeat}
  .container{max-width:1200px;margin:28px auto;padding:0 16px}
  h1{margin:0 0 16px}
  .panel{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:14px;margin-bottom:16px;backdrop-filter:saturate(120%) blur(2px)}
  label{display:block;margin:0 0 6px}
  input[type="text"]{width:100%;padding:12px;border-radius:10px;border:1px solid var(--border);background:rgba(255,255,255,.06);color:var(--text);outline:none;font-size:15px}
  .muted{color:var(--muted);font-size:14px}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
  @media (max-width:960px){.grid{grid-template-columns:1fr}}
  table{width:100%;border-collapse:collapse;border-radius:12px;overflow:hidden}
  thead th{background:var(--head);padding:10px;text-align:center;border-bottom:1px solid var(--border)}
  tbody td{padding:10px;text-align:center;border-bottom:1px solid rgba(255,255,255,.06);background:rgba(255,255,255,.03)}
  tr:nth-child(even) td{background:rgba(255,255,255,.045)}
  tfoot td{padding:10px;font-weight:700;background:rgba(255,255,255,.06)}
  .dropdown{position:relative}
  .dropdown-menu{position:absolute;left:0;right:0;z-index:10;margin-top:6px;max-height:300px;overflow:auto;background:var(--card);border:1px solid var(--border);border-radius:10px;display:none}
  .dropdown-item{padding:8px 10px;cursor:pointer}
  .dropdown-item:hover{background:rgba(255,255,255,.06)}
  .row{display:flex;gap:12px;align-items:center;margin-top:8px}
</style>
</head>
<body>
  <div class="container">
    <h1>Bazaar Orders</h1>

    <div class="panel">
      <div class="dropdown">
        <label for="itemInput">Item ID</label>
        <input id="itemInput" type="text" autocomplete="off" placeholder="Type e.g. BOOSTER_COOKIE, then Enter"/>
        <div id="dd" class="dropdown-menu"></div>
      </div>
      <label class="row muted" style="user-select:none;">
        <input id="groupToggle" type="checkbox" checked />
        Group orders within ±0.1% (amounts rounded)
      </label>
      <div class="muted" id="status" style="margin-top:6px;"></div>
    </div>

    <div class="grid">
      <div class="panel">
        <h2 style="margin:0 0 10px;">Buy Orders (expensive → cheapest)</h2>
        <table id="buyTable">
          <thead><tr><th>Orders</th><th>Amount</th><th>Unit Price</th><th>Coin Equivalent</th></tr></thead>
          <tbody><tr><td colspan="4" class="muted">No data</td></tr></tbody>
          <tfoot><tr><td>Total:</td><td></td><td></td><td></td></tr></tfoot>
        </table>
      </div>

      <div class="panel">
        <h2 style="margin:0 0 10px;">Sell Orders (cheapest → expensive)</h2>
        <table id="sellTable">
          <thead><tr><th>Orders</th><th>Amount</th><th>Unit Price</th><th>Coin Equivalent</th></tr></thead>
          <tbody><tr><td colspan="4" class="muted">No data</td></tr></tbody>
          <tfoot><tr><td>Total:</td><td></td><td></td><td></td></tr></tfoot>
        </table>
      </div>
    </div>
  </div>

<script>
  const API_BASE = 'https://wato-api.vercel.app';
  const REFRESH_MS = 30000;
  const GROUP_PCT = 0.1; // ±0.1%

  // Local, guaranteed list; extend as you add items to WATO.
  let SUPPORTED = [
    'BOOSTER_COOKIE',
    'RECOMBOBULATOR_3000',
    'ENCHANTED_DIAMOND_BLOCK',
    'KISMET_FEATHER',
    'SUMMONING_EYE',
    'ESSENCE_CRIMSON',
    'SKELETON_KEY',
    'TITANIC_EXP_BOTTLE'
  ];

  let currentItem = '';
  let timer = null;
  let useGrouping = true;

  const el = sel => document.querySelector(sel);
  const itemInput = el('#itemInput');
  const ddMenu    = el('#dd');
  const statusEl  = el('#status');
  const groupToggle = el('#groupToggle');

  const asCoins = n => Number(n||0).toLocaleString(undefined,{maximumFractionDigits:3});

  // Optional: merge remote /usage if present
  (async function maybeMergeUsage(){
    try{
      const r = await fetch(`${API_BASE}/usage`, {cache:'no-store'});
      if (r.ok){
        const j = await r.json();
        const remote = Array.isArray(j.items) ? j.items
                     : Array.isArray(j.usage) ? j.usage
                     : [];
        if (remote.length){
          const set = new Set([...SUPPORTED, ...remote.map(x=>String(x).toUpperCase())]);
          SUPPORTED = Array.from(set).sort();
        }
      }
    }catch(_){}
  })();

  function groupSummary(rows){
    if (!rows || !rows.length) return [];
    const tol = GROUP_PCT/100;
    const sorted = rows.slice().sort((a,b)=> a.pricePerUnit - b.pricePerUnit);
    const out = [];
    let cur = null;
    for(const r of sorted){
      const amt = Number(r.amount)||0;
      const price = Number(r.pricePerUnit)||0;
      const ord = Number(r.orders ?? r.orders_count ?? 0);
      const chunk = {amount:amt, pricePerUnit:price, orders:ord, _coins: amt*price};
      if(!cur){ cur = {...chunk}; continue; }
      const rel = Math.abs(chunk.pricePerUnit - cur.pricePerUnit) / (cur.pricePerUnit || 1);
      if (rel <= tol){
        cur.orders += chunk.orders;
        cur.amount += chunk.amount;
        cur._coins += chunk._coins;
        cur.pricePerUnit = cur._coins / (cur.amount || 1);
      } else {
        cur.amount = Math.round(cur.amount);
        out.push(({_coins, ...rest}=cur, rest));
        cur = {...chunk};
      }
    }
    if (cur){ cur.amount = Math.round(cur.amount); out.push(({_coins, ...rest}=cur, rest)); }
    return out;
  }

  function renderTable(rows, tbody, tfootRow) {
  tbody.innerHTML = '';
  if (!rows.length) {
    const tr = document.createElement('tr');
    const td = document.createElement('td');
    td.colSpan = 4;
    td.className = 'muted';
    td.textContent = 'No data';
    tr.appendChild(td);
    tbody.appendChild(tr);
    tfootRow.innerHTML = '<td>Total:</td><td></td><td></td><td></td>';
    return;
  }

  let totalAmt = 0, totalCoins = 0;
  for (const r of rows) {
    const amount = Math.round(Number(r.amount) || 0);
    const priceRaw = Number(r.pricePerUnit) || 0;
    const priceDisplay = useGrouping ? Math.round(priceRaw) : priceRaw; // ✅ Round only if grouping
    const orders = Number(r.orders ?? r.orders_count ?? 0);
    const coins = amount * priceRaw;

    totalAmt += amount;
    totalCoins += coins;

    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${orders}</td>
      <td>${amount.toLocaleString()}</td>
      <td>${asCoins(priceDisplay)}</td>
      <td>${asCoins(coins)}</td>
    `;
    tbody.appendChild(tr);
  }

  tfootRow.innerHTML = `
    <td>Total:</td>
    <td>${totalAmt.toLocaleString()}</td>
    <td></td>
    <td>${asCoins(totalCoins)}</td>
  `;
}

  function renderTables(buyOrders, sellOrders){
    let buyData  = useGrouping ? groupSummary(sellOrders)  : sellOrders.slice();
    let sellData = useGrouping ? groupSummary(buyOrders) : buyOrders.slice();

    // ALWAYS sort post-grouping:
    buyData.sort((a,b)=> b.pricePerUnit - a.pricePerUnit); // high → low
    sellData.sort((a,b)=> a.pricePerUnit - b.pricePerUnit); // low → high

    renderTable(buyData,  el('#buyTable tbody'),  el('#buyTable tfoot tr'));
    renderTable(sellData, el('#sellTable tbody'), el('#sellTable tfoot tr'));
  }

  async function load(itemId){
    if (!itemId) return;
    statusEl.textContent = 'Loading…';
    try{
      const res = await fetch(`${API_BASE}/${encodeURIComponent(itemId)}`, {cache:'no-store'});
      if (!res.ok) throw new Error(`${res.status}`);
      const data = await res.json(); // { buy_summary:[], sell_summary:[] }
      const buys  = Array.isArray(data.buy_summary)  ? data.buy_summary  : [];
      const sells = Array.isArray(data.sell_summary) ? data.sell_summary : [];
      renderTables(buys, sells);
      statusEl.textContent = `Updated ${new Date().toLocaleTimeString()}`;
    }catch(e){
      console.error(e);
      statusEl.textContent = 'Error loading data';
      renderTables([],[]);
    }
  }

  function startPolling(){
    if (timer) clearInterval(timer);
    timer = setInterval(()=> load(currentItem), REFRESH_MS);
  }

  // ----- dropdown helpers -----
  function openDropdown(list){
    ddMenu.innerHTML = '';
    list.slice(0,100).forEach(id=>{
      const div = document.createElement('div');
      div.className='dropdown-item';
      div.textContent = id;
      div.onclick = ()=> selectItem(id);
      ddMenu.appendChild(div);
    });
    ddMenu.style.display = list.length ? 'block' : 'none';
  }
  function filterList(q){
    q = (q||'').toUpperCase();
    if (!q){ ddMenu.style.display='none'; return; }
    openDropdown(SUPPORTED.filter(id => id.includes(q)));
  }
  function selectItem(id){
    currentItem = id.toUpperCase();
    itemInput.value = currentItem;
    ddMenu.style.display = 'none';
    history.replaceState({}, '', `?item=${encodeURIComponent(currentItem)}`);
    load(currentItem);
    startPolling();
  }

  // events
  let deb;
  itemInput.addEventListener('input', ()=>{
    clearTimeout(deb);
    deb = setTimeout(()=> filterList(itemInput.value), 120);
  });
  itemInput.addEventListener('focus', ()=>{
    openDropdown(SUPPORTED.slice(0,100));
  });
  itemInput.addEventListener('keydown', (e)=>{
    if (e.key === 'Enter'){
      const v = itemInput.value.trim().toUpperCase();
      if (SUPPORTED.includes(v)) selectItem(v);
      else {
        // pick first suggestion if any
        const first = SUPPORTED.find(id => id.includes(v));
        if (first) selectItem(first);
      }
    }
  });
  document.addEventListener('click', (e)=>{
    if (!ddMenu.contains(e.target) && e.target !== itemInput) ddMenu.style.display='none';
  });
  groupToggle.addEventListener('change', ()=>{
    useGrouping = groupToggle.checked;
    load(currentItem);
  });

  // init: preselect ?item=
  (function init(){
    const u = new URL(location.href);
    const pre = (u.searchParams.get('item')||'').toUpperCase();
    if (pre && SUPPORTED.includes(pre)) selectItem(pre);
    else itemInput.focus();
  })();
</script>
</body>
</html>
